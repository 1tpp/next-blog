---
title: 10 ประเภทของอัลกอริทึม
date: '2021-08-08'
tags: ['algorithm']
draft: false
summary: เราจะแยกประเภทของอัลกิรึทึมได้ยังไร?
---

## ประเภทของอัลกอริทึม

การแยกประเภทของอัลกอริทึมแยกตามรูปแบบการแก้ไขปัญหาของอัลกอริทึม โดยแยกประเภทของอัลกอริทึมได้ดังนี้

### 1. Brute force alogorithm

**Brute force alogorithm**
เป็นอัลกอริทึมสำหรับแก้ไขปัญหาโดยสั่งให้ทำงานไปเรื่อยๆ จนกระทั้งได้คำตอบของทุกปัญหา การแก้ไขปัญหารูปแบบนี้ไม่เหมาะสำหรับแก้ปัญหาที่มีข้อมูลจำนวนมาก

ตัวอย่างอัลกอริทึมที่ใช้หลักการ Brute Force agorithm เช่น การจัดเรียงข้อมูลแบบ Bubble sort, Merge sort เป็นต้น

| [Bubble Sort](https://en.wikipedia.org/wiki/Bubble_sort)                                                  | [Selection Sort](https://en.wikipedia.org/wiki/Selection_sort)                                      |
| --------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------- |
| ![ฺBubble_sort_tAnima](https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif) | ![Selection-Sort](https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif) |

### 2. Divide and Conquer alogithm

**Divide and Conquer alogithm**
เป็นอัลกอริทึมที่หลักการคิดโดยแยกปัญหาออกเป็นสองส่วน คือ ส่วนที่หนึ่งแบ่งปัญหาออกเป็นเล็กๆ แล้วแก้ไขปัญหาส่วนเล็กๆ นั้นก่อน และอีกส่วนนำผลที่ได้จากการแกข้ไขปัญหาในส่วนเล็ก กลับมาร่วมกันใหม่

ตัวอย่างอัลกอริทึมที่ใช้หลักการ Divide and Conquer algorithm เช่น การจัดเรียงข้อมูลแบบ Quick Sort, Merge sort เป็นต้น

| [Quick sort](https://en.wikipedia.org/wiki/Quicksort)                                                     | [Merge sort](https://en.wikipedia.org/wiki/Merge_sort)                                                            |
| --------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| ![Sorting_quicksort_anim](https://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif) | ![Merge-sort-example-300px.gif](https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif) |

### 3. Decrease and Conquer alogithm

**Decrease and Conquer alogithm**
เป็นอัลกอริทึมที่แก้ไขปัญหาด้วยการลดขนาดของปัญหาลง และ เลือกขนาดของกลุ่มปัญหาที่ต้องการแก้ไขปัญหา โดยละเว้นปัญหาบางส่วนไว้ก่อน เพื่อจะแก้ปัญหาที่มีขนาดเล็กลงกว่าเดิม เนื่องจากการแก้ไขปัญหาที่มีขนาดเล็กกส่าจะสามารถแก้ไขปัญหาได้ง่ายกว่า

ตัวอย่างอัลกอริทึมที่ใช้หลักการ Decrease and Conquer algorithm เช่น การค้นหาข้อมูลแบบไบนารี เป็นต้น

| [Binary search](https://en.wikipedia.org/wiki/Binary_search_algorithm)
| --------------------------------------------------------------------------------------------------------- |
| ![Binary Search Depiction.svg](https://upload.wikimedia.org/wikipedia/commons/8/83/Binary_Search_Depiction.svg) |

### 4. Transform and Conquer alogithm

**Transform and Conquer alogithm**
เป็นอัลกอริทึมที่หลักการแก้ไขปัญหาโดยการเปลี่ยนรูปแบบของปัญหาที่ต้องการแก้ไขให้อยู่ในรูปแบบอื่นก่อน ด้วยคาดหวังว่าเมื่อเปลี่ยนรูปแบบของปัญหาแล้วจะสามารถแก้ไขปัญหาได้ง่ายและรวดเร็ว

ตัวอย่างในการเปลี่ยนโครงสร้างข้อมูลก่อนการแก้ไขปัญหา เช่น การนำข้อมูลที่ต้องการค้นหามาจัดเรียงข้อมูลก่อนที่จะค้นหา เพื่อให้สามารถใช้อัลกอริทึมที่มีประะสิทธิภาพค้นหาข้อมูลได้แทนที่จะค้นหาข้อมูลทีละตัวจากข้อมูลที่กระจัดกระจาย

### 5. Greedy algorithm

**Greedy algorithm** หรือ **อัลกอริทึมแบบละโมบ**
เป็นอัลกอริทึมที่มีลักษณะของการแก้ไขปัญหาด้วยการเพิ่มประสิทธิภาพของการแก้ไขปัญหาให้เหมาะสมที่สุด (Optimization probleam) ซึ่งเป็นรูปแบบอัลกอริทึมที่พิจารณาคำตอบที่ดีที่สุดและคุ้มค่าที่สุดในการแก้ไขปัญหานั้นๆ

ตัวอย่างอัลกอริทึมที่ใช้หลักการ Greedy algorithm ในการแก้ไขปัญหาเช่น ปัญหาการทอนเหรียญจากหน่วยที่มีขนาดใหญ่ที่สุดก่อน เป็นต้น

### 6. Dynamic programming algorithm

**Dynamic programming algorithm** หรือ **อัลกอริทึมแบบมีพลวัต**
เป็นอัลกอริทึมที่มีลักษณะของการแก้ไขปัญหาด้วยการแบ่งปัญหาเป็นส่วนเล็กๆ แล้วนำผลของปัญหาเล็กๆ ที่ดีที่สุดนำมาแก้ไขปัญหาใหญ่ที่เรียกกันว่า การแก้ไขปัญหาจากล่างขึ้นบน(Bottom-up approach)

ตัวอย่างอัลกอริทึมที่ใช้หลักการ Dynamic programming algorithm ในการแก้ไขปัญหาเช่น เช่นการหาค่าตัวเลข Fibonacci เป็นต้น

### 7. Backtracking algorithm

**Backtracking algorithm** หรือ **อัลกอริทึมแบบย้อนรอยถอยหลัง**
เป็นอัลกอริทึมค้นหาเส้นทางทุกเส้นทางที่เป็นไปได้เพื่อหาคำตอบของปัญหาทีละส่วนย่อยว่า คำตอบที่ถูกต้องหรือไม่ แต่คำตอบนั้นไม่ใช่ส่วนหนึ่งของคำตอบจะถอยหลังกลับมาจุดเดิม และยกเลิกคำตอบนั้นแล้วค้นหาคำตอบใหม่

ตัวอย่างอัลกอริทึมที่ใช้หลักการ Backtracking algorithm เช่น การกำหนดสีให้กับเมืองในแผนที่, คิดความเป็นไปได้ทั้งหมดของการเดินหมากกระดาน เป็นต้น

### 8. Branch and bound algorithm

**Branch and bound algorithm**
เป็นอัลกอริทึมที่เพิ่มประสิทธิภาพในการแก้ไขปัญหา ด้วยการนำ โครงสร้างทรี(Tree) มาเก็บปัญหาย่อยๆ โดยปัญหาหลักจะอยู่ในตำแหน่งบนสุดของ ทรี หรือ คือ โหนดราก(Root node) และในแต่ละโหนดจะแก้ไขปัญหาของตัวเอง และถ้าแก้ปัญหาถูกต้องก็จะใช้ผลนั้นเป็นข้อมูลในการแก้ไขปัญหาทั้งหมด แต่ถ้าการแก้ไขปัญหาไม่ถูกต้องให้แบ่งปัญหาออกเป็นสองโหนดย่อยเก็บไว้ในตำแหน่งโหนดลูกของโหนดที่แก้ไขไม่ถูกต้อง แล้วกลับไปทำใหม่จนกระทั้งทุกโหนดย่อยในทรีสามารถแก้ไขปัญหาได้ทุกโหนด

ตัวอย่างอัลกอริทึมที่ใช้หลักการ Branch and bound algorithm มาใช้ในการแก้ไขปัญหา เช่น ปัญหาในการหาเส้นทางที่เหมาะสมให้กับพนักงานขายสินค้าให้สามารถเดินทางได้ครบทุกที่ได้เร็วที่สุด เป็นต้น

### 9. Recursive algorithm

**Recursive algorithm** หรือ **อัลกอริทึมแบบเรียกซ้ำ**
เป็นอัลกอริทึมสำหรับการแก้ไขปัญหาขั้นพื้นฐานด้วยการเรียกใช้ตัวเองซ้ำๆ โดนนำข้อมูลปัญหาส่วนย่อยของปัญหาทั้งหมดกลับมาเป็นข้อมูลในการแก้ไขปัญหา

ตัวอย่างอัลกอริทึมแบบเรียกซ้ำ เช่น การหาค่า Factorial, อัลกอริทึมบวกข้อมูลตัวเลขที่อยู้ในกลุ่มเป็นต้น

### 10. Ramdomized algorithm

**Ramdomized algorithm** หรือ **อัลกอริทึมแบบสุ่ม**
เป็นอัลกอริทึมที่ใช้หลักการสุ่มข้อมูล แล้วนำข้อมูลที่สุ่มเลือกขึ้นมาได้กระทำกับอัลกอริทึมเพื่อให้ได้ผลตามที่ต้องการ

ตัวอย่างอัลกอริทึมที่ใช้หลักการ Randomized algorithm ไปใช้งาน เช่น พยายามหาข้อมูลที่สำคัญที่สุดด้วยการเลือกข้อมูลจากการสุ่มด้วยการหาร หรือการจัดเรียงข้อมูลแบบ Quciksort ด้วยการสุ่มตัวเลขหนึ่งตัวขึ้นมาเพื่อใช้สำหรับเปรียบ(pivot) ข้อมูลที่ยังไม่ได้จัดเรียงข้อมูล เป็นต้น
